## Виды контекста

```
ctx, cancel := context.Background()
```
Эта функция возвращает пустой констекст. Используется в main, тестах или в точке входа

```
ctx, cancel := context.TODO()
```
Эта функция возвращает пустой констекст. Используется когда вы не уверены, какой контекст использовать, или если в функции еще нет получения нужного контекста

```
context.WithCancel(parentCtx)
```
Эта функция возвращает констекст, который можно вручную отменить через вызов cancel().

```
context.WithTimeout(parentCtx, duration)
```
Эта функция похожа на context.WithDeadline. Разница в том, что в качестве входных данных используется длительность времени. Эта функция возвращает производный контекст, который отменяется при вызове функции отмены или по истечении времени.

```
context.WithDeadline(parentCtx, time.Time)
```
Эта функция возвращает производный контекст от своего родителя, который отменяется после дедлайна или вызова функции отмены

```
context.WithValue(parentCtx, key, val)
```
Эта функция принимает контекст и возвращает производный от него контекст, в котором значение val связано с key и проходит через всё контекстное дерево. То есть, как только вы создадите контекст WithValue, любой производный контекст получит это значение.

## Случаи возникновения deadlock

```
package main

import (
    "fmt"
)

func main() {
	ch := make(chan int)
	ch <- 1
	close(ch)
	val := <-ch
	fmt.Println(val)
}

```
Блокируется, и поскольку никто не может прочитать, то ловим deadlock

```
package main

import (
    "sync"
    "time"
)

func main() {
    var mu sync.Mutex
    mu.Lock()
    go func() {
        mu.Lock() // deadlock
    }()

    time.Sleep(1 * time.Second)
    mu.Unlock()
}

```
В этом примере блокировка второй горутины происходит из-за того, что мутекс уже занят основной горутиной и не освобожден вовремя.